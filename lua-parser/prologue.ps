% generated by lua2ps
% lua2ps by Don Viszneki don@codebad.com
% Lua table keys are dynamically typed, so we don't need to worry about
% coercing keys to string or anything like that.
% But Lua tables also know their "array length," so we need to take care
% for that, and also avoid key collisions. Rather than bend over backward
% <dict-initial-size> luaTableNew <dict>
/luaTableNew {
  dict
  dup (luaLength) 0 put
} def
% <key> luaPrepareTableKey <key2> <isInteger>
% Prepends (__lua_key_) to a stringtype key, and also tells whether or
% not the key is an integertype.
/luaPrepareTableKey {
  % stack: <key>
  dup type (stringtype) eq {
    (Found String Key) ==
    % stack: <key>
    % First we prefix the key
    dup length % Get key string length
    % stack: <key> keylen
    % Create a new string to contain the concatenated result
    10 add string
    dup dup
    % stack: <key> <key2> <key2> <key2>
    0 (__lua_key_) putinterval 10 3 % strcat prefix
    % stack: <key> <key2> <key2> 10 3
    index
    % stack: <key> <key2> <key2> 10 <key>
    putinterval
    % stack: <key> <key2>
    exch
    % stack: <key2> <key>
    pop false
    % stack: <key2> isInteger:false
  } {
    (Found non-String key) ==
    % stack: <key2> % key is already key2
    dup type (integertype) eq
    % stack: <key2> isInteger:bool
  }
  % String key? 
  ifelse
  % stack: <key2> isString:bool
} def
% <dict> <key> luaTableGet <null|value>
/luaTableGet {
  % stack: <dict> <key>
  luaPrepareTableKey
  % stack: <dict> <key2> <isInteger>
  pop
  % stack: <dict> <key2>
  1 index
  1 index
  % stack: <dict> <key2> <dict> <key2>
  known % is <key2> in <dict> ?
  % stack: <dict> <key2> isKnown
  {
    % stack: <dict> <key2> isKnown
    get
    % stack: <value>
  } {
    % stack: <dict> <key2> isKnown
    pop pop null
    % stack: <value:null>
  }
  % stack: <dict> <key2> isKnown
  ifelse
  % stack: <value>
} def
% <dict> <key> <value> luaTableSet -
/luaTableSet {
  % stack: <dict> <key> <value>
  exch % put <key> on top, to be consumed by luaPrepareTableKey
  % stack: <dict> <value> <key>
  luaPrepareTableKey
  % stack: <dict> <value> <key2> <isInteger>
  {
    (Setting Integer Key) ==
    % stack: <dict> <value> <key2>
    2 index % push <dict>
    % stack: <dict> <value> <key2> <dict>
    (luaLength) get % fetch Lua "#table" from <dict>
    % stack: <dict> <value> <key2> #table
    1 add % calculate #table+1
    % stack: <dict> <value> <key2> #table+1
    1 index % push <key2> for comparison
    % stack: <dict> <value> <key2> #table+1 <key2>
    eq % perform comparison
    % stack: <dict> <value> <key2> needIncrement:bool
    {
      (Incrementing!) ==
      % stack: <dict> <value> <key2>
      % we need to put a value into our dict, so
      2 index % push <dict>
      % stack: <dict> <value> <key2> <dict>
      (luaLength) % push (luaLength)
      % stack: <dict> <value> <key2> <dict> (luaLength)
      2 index % push <key2>, which is also #table+1
      % stack: <dict> <value> <key2> <dict> (luaLength) <key2>
      put % update the table's #table
      % stack: <dict> <value> <key2>
    } {
      (Not incrementing!) ==
      % stack: <dict> <value> <key2>
    }
    % stack: <dict> <value> <key2> needIncrement:bool {trueproc} {falseproc}
    ifelse % branch
    % stack: <dict> <value> <key2>
  } {
    (Setting non-Integer Key) ==
    % stack: <dict> <value> <key2>
  }
  % stack: <dict> <value> <key2> <isInteger>
  ifelse
  % stack: <dict> <value> <key2>
  exch
  % stack: <dict> <key2> <value>
  put % set the table's key!
  % stack: empty!
} def
% <dict> luaTableLength "#table"
/luaTableLength {
  (luaLength) get
} def
