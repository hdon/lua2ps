% generated by lua2ps
% lua2ps by Don Viszneki don@codebad.com

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%   BEGINNING OR PROLOGUE.  A SORT OF RUNTIME LIB FOR LUA2PS        %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%true % enable trace output
false % disable trace output
{{ == }} {{ pop }} ifelse /trace exch def

% Lua table keys are dynamically typed, so we don't need to worry about
% coercing keys to string or anything like that.
% But Lua tables also know their "array length," so we need to take care
% for that, and also avoid key collisions. Rather than bend over backward
% <dict-initial-size> luaTableNew <dict>
/luaTableNew {
  dict
  dup (luaLength) 0 put
} def
% <key> luaPrepareTableKey <key2> <isInteger>
% Prepends (__lua_key_) to a stringtype key, and also tells whether or
% not the key is an integertype.
/luaPrepareTableKey {
  % stack: <key>
  dup type (stringtype) eq {
    (Found String Key) trace
    % stack: <key>
    % First we prefix the key
    dup length % Get key string length
    % stack: <key> keylen
    % Create a new string to contain the concatenated result
    10 add string
    dup dup
    % stack: <key> <key2> <key2> <key2>
    0 (__lua_key_) putinterval 10 3 % strcat prefix
    % stack: <key> <key2> <key2> 10 3
    index
    % stack: <key> <key2> <key2> 10 <key>
    putinterval
    % stack: <key> <key2>
    exch
    % stack: <key2> <key>
    pop false
    % stack: <key2> isInteger:false
  } {
    (Found non-String key) trace
    % stack: <key2> % key is already key2
    dup type (integertype) eq
    % stack: <key2> isInteger:bool
  }
  % String key? 
  ifelse
  % stack: <key2> isString:bool
} def
% <dict> <key> luaTableGet <null|value>
/luaTableGet {
  % stack: <dict> <key>
  luaPrepareTableKey
  % stack: <dict> <key2> <isInteger>
  pop
  % stack: <dict> <key2>
  1 index
  1 index
  % stack: <dict> <key2> <dict> <key2>
  known % is <key2> in <dict> ?
  % stack: <dict> <key2> isKnown
  {
    % stack: <dict> <key2> isKnown
    get
    % stack: <value>
  } {
    % stack: <dict> <key2> isKnown
    pop pop null
    % stack: <value:null>
  }
  % stack: <dict> <key2> isKnown
  ifelse
  % stack: <value>
} def
% <dict> <key> <value> luaTableSet -
/luaTableSet {
  % stack: <dict> <key> <value>
  exch % put <key> on top, to be consumed by luaPrepareTableKey
  % stack: <dict> <value> <key>
  luaPrepareTableKey
  % stack: <dict> <value> <key2> <isInteger>
  {
    (Setting Integer Key) trace
    % stack: <dict> <value> <key2>
    2 index % push <dict>
    % stack: <dict> <value> <key2> <dict>
    (luaLength) get % fetch Lua "#table" from <dict>
    % stack: <dict> <value> <key2> #table
    1 add % calculate #table+1
    % stack: <dict> <value> <key2> #table+1
    1 index % push <key2> for comparison
    % stack: <dict> <value> <key2> #table+1 <key2>
    eq % perform comparison
    % stack: <dict> <value> <key2> needIncrement:bool
    {
      (Incrementing!) trace
      % stack: <dict> <value> <key2>
      % we need to put a value into our dict, so
      2 index % push <dict>
      % stack: <dict> <value> <key2> <dict>
      (luaLength) % push (luaLength)
      % stack: <dict> <value> <key2> <dict> (luaLength)
      2 index % push <key2>, which is also #table+1
      % stack: <dict> <value> <key2> <dict> (luaLength) <key2>
      put % update the table's #table
      % stack: <dict> <value> <key2>
    } {
      (Not incrementing!) trace
      % stack: <dict> <value> <key2>
    }
    % stack: <dict> <value> <key2> needIncrement:bool {trueproc} {falseproc}
    ifelse % branch
    % stack: <dict> <value> <key2>
  } {
    (Setting non-Integer Key) trace
    % stack: <dict> <value> <key2>
  }
  % stack: <dict> <value> <key2> <isInteger>
  ifelse
  % stack: <dict> <value> <key2>
  exch
  % stack: <dict> <key2> <value>
  put % set the table's key!
  % stack: empty!
} def
% <dict> luaTableLength "#table"
/luaTableLength {
  (luaLength) get
} def

% Implementation of Lua's "not" operator. Note: In PostScript we use 'null' to represent
% Lua's 'nil' value. Lua's logical operators consider 'false' and 'nil' as its only falsy
% values.
/luaNot {
  dup false eq
    { pop true }
    { null eq
      { true }
      { false }
      ifelse
    }
    ifelse
} def

% These are magic functions which can be called by Lua, but which are implemented
% natively in PostScript! As such, they must respect the lua2ps calling conventions
% for Lua functions.

/__lua_G_print {
  {
    dup mark eq { pop exit } { == } ifelse
  } loop
  null % current Lua calling convention requires exactly one return value
} def

% This is used by the PostScript emitter in the lua2ps translator to handle implicit
% local variables. A PostScript optimizer I am dreaming up will remove this automatically
% for us! (Hi Rickie)
/phony { } def
% This is used by the PostScript emitter to pop a mark where the calling convention actually
% requires that the callee clean up its own stack, and the mark along with it.
/kram { } def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%   END    OF   THE   PROLOGUE.   GENERATED   CODE  STARTS   HERE!  %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
